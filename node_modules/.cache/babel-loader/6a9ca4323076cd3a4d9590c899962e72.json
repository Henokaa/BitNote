{"ast":null,"code":"\"use strict\"; // When debugging it helps to see what payload youtube-dl returns. You\n//   could do it like this\n//\n//   $ youtube-dl --write-auto-sub --skip-download -j https://www.youtube.com/watch?v=TImPW-khOww | prettyjson\n\nconst PythonShell = require('python-shell');\n\nvar appRoot = require('app-root-path');\n\nvar beautify = require(\"json-beautify\");\n\nvar json = require('format-json');\n\nconst loudRejection = require('loud-rejection');\n\nloudRejection();\n\nfunction NonExistentSubtitleError(message) {\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nNonExistentSubtitleError.prototype = Error.prototype;\n\nfunction getAutoSubs(videoId) {\n  return new Promise((resolve, reject) => {\n    PythonShell.run('__main__.py', {\n      scriptPath: `${__dirname}/youtube-dl/youtube_dl`,\n      args: ['--write-auto-sub', '-j', '--skip-download', '--sub-format', 'vtt', `https://www.youtube.com/watch?v=${videoId}`]\n    }, (err, results) => {\n      if (err) {\n        reject(err);\n      } else {\n        var response = JSON.parse(results[0]);\n        var automatic_captions = response[\"automatic_captions\"];\n        var english_captions = automatic_captions[\"en\"];\n        var english_vtt_captions = automatic_captions[\"en\"].filter((caption, index) => caption[\"ext\"] === \"vtt\")[0];\n        var english_vtt_captions_url = english_vtt_captions[\"url\"];\n        resolve(english_vtt_captions_url);\n      }\n    });\n  });\n}\n\nfunction getNonAutoSubs(videoId) {\n  return new Promise((resolve, reject) => {\n    PythonShell.run('__main__.py', {\n      scriptPath: `${__dirname}/youtube-dl/youtube_dl`,\n      args: ['--write-sub', '-j', '--skip-download', '--sub-format', 'vtt', `https://www.youtube.com/watch?v=${videoId}`]\n    }, (err, results) => {\n      if (err) {\n        reject(err);\n      } else {\n        // console.log(results)\n        var response = JSON.parse(results[0]);\n        var automatic_captions = response[\"requested_subtitles\"];\n        var english_captions = automatic_captions[\"en\"];\n        var english_captions_url = english_captions[\"url\"];\n        resolve(english_captions_url);\n      }\n    });\n  });\n}\n\nfunction getYoutubeSubtitleUrl(videoId, opts) {\n  opts = opts || {};\n  var type = 'either'; // onlye accepts auto and nonauto type\n\n  if (opts.type && opts.type !== 'auto' && opts.type !== 'nonauto' && opts.type !== 'either') {\n    throw new Error('type is not valid');\n  } // default should be either \n\n\n  if (opts.type === 'auto' || opts.type === 'nonauto') {\n    type = opts.type;\n  }\n\n  return new Promise((resolve, reject) => {\n    if (type === 'nonauto') {\n      getNonAutoSubs(videoId).then(url => {\n        const result = {\n          automaticallyGenerated: false,\n          url\n        };\n        resolve(result);\n      }).catch(err => {\n        if (err.message.indexOf(\"video doesn't have subtitles\")) {\n          // reject(new NonExistentSubtitleError(`Non-auto Subtitles dont exist for ${videoId}`));\n          reject(`Subtitles dont exist for ${videoId}`);\n        } else {\n          reject(err);\n        }\n      });\n    } else if (type === 'auto') {\n      getAutoSubs(videoId).then(url => {\n        const result = {\n          automaticallyGenerated: true,\n          url\n        };\n        resolve(result);\n      }).catch(err => {\n        if (err.message.indexOf(\"Couldn't find automatic captions for\")) {\n          // reject(new NonExistentSubtitleError(`Auto Subtitles dont exist for ${videoId}`));\n          reject(`Auto Subtitles dont exist for ${videoId}`);\n        } else {\n          reject(err);\n        }\n      });\n    } else if (type === 'either') {\n      getNonAutoSubs(videoId).then(url => {\n        const result = {\n          automaticallyGenerated: false,\n          url\n        };\n        resolve(result);\n      }).catch(() => {\n        getAutoSubs(videoId).then(url => {\n          const result = {\n            automaticallyGenerated: true,\n            url\n          };\n          resolve(result);\n        }).catch(err => {\n          if (err.message.indexOf(\"Couldn't find automatic captions for\")) {\n            // reject(new NonExistentSubtitleError(`Subtitles dont exist for ${videoId}`));\n            reject(`Auto Subtitles dont exist for ${videoId}`);\n          } else {\n            reject(err);\n          }\n        });\n      });\n    }\n  });\n} // export default getYoutubeSubtitleUrl;\n\n\nmodule.exports = {\n  default: getYoutubeSubtitleUrl\n};","map":{"version":3,"sources":["C:/Users/Henok/Desktop/3D/Front end mmasters/firebase with react V2/BitNote/BitNote/BitNote/node_modules/@joegesualdo/get-youtube-subtitle-url-node/index.js"],"names":["PythonShell","require","appRoot","beautify","json","loudRejection","NonExistentSubtitleError","message","stack","Error","prototype","getAutoSubs","videoId","Promise","resolve","reject","run","scriptPath","__dirname","args","err","results","response","JSON","parse","automatic_captions","english_captions","english_vtt_captions","filter","caption","index","english_vtt_captions_url","getNonAutoSubs","english_captions_url","getYoutubeSubtitleUrl","opts","type","then","url","result","automaticallyGenerated","catch","indexOf","module","exports","default"],"mappings":"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","sourcesContent":["\"use strict\"\n\n// When debugging it helps to see what payload youtube-dl returns. You\n//   could do it like this\n//\n//   $ youtube-dl --write-auto-sub --skip-download -j https://www.youtube.com/watch?v=TImPW-khOww | prettyjson\n\nconst PythonShell = require('python-shell');\nvar appRoot = require('app-root-path');\nvar beautify = require(\"json-beautify\");\nvar json = require('format-json');\n\nconst loudRejection = require('loud-rejection');\nloudRejection();\n\nfunction NonExistentSubtitleError(message) {\n  this.message = message;\n  this.stack = (new Error().stack);\n}\nNonExistentSubtitleError.prototype = Error.prototype;\n\nfunction getAutoSubs(videoId) {\n  return new Promise((resolve, reject) => {\n    PythonShell.run('__main__.py', {\n      scriptPath: `${__dirname}/youtube-dl/youtube_dl`,\n      args: [\n        '--write-auto-sub',\n        '-j',\n        '--skip-download',\n        '--sub-format',\n        'vtt',\n        `https://www.youtube.com/watch?v=${videoId}`],\n    }, (err, results) => {\n      if (err) {\n        reject(err);\n      } else {\n          var response = JSON.parse(results[0])\n          var automatic_captions = response[\"automatic_captions\"]\n          var english_captions = automatic_captions[\"en\"]\n          var english_vtt_captions = automatic_captions[\"en\"].filter((caption, index) => caption[\"ext\"] === \"vtt\")[0]\n          var english_vtt_captions_url = english_vtt_captions[\"url\"]\n          resolve(english_vtt_captions_url);\n      }\n    });\n  });\n}\n\nfunction getNonAutoSubs(videoId) {\n  return new Promise((resolve, reject) => {\n    PythonShell.run('__main__.py', {\n      scriptPath: `${__dirname}/youtube-dl/youtube_dl`,\n      args: [\n        '--write-sub',\n        '-j',\n        '--skip-download',\n        '--sub-format',\n        'vtt',\n        `https://www.youtube.com/watch?v=${videoId}`],\n    }, (err, results) => {\n\n      if (err) {\n        reject(err);\n      } else {\n        // console.log(results)\n        var response = JSON.parse(results[0])\n        var automatic_captions = response[\"requested_subtitles\"]\n        var english_captions = automatic_captions[\"en\"]\n        var english_captions_url = english_captions[\"url\"]\n        resolve(english_captions_url);\n      }\n    });\n  });\n}\n\nfunction getYoutubeSubtitleUrl(videoId, opts) {\n  opts = opts || {}\n  var type = 'either'\n  // onlye accepts auto and nonauto type\n  if (opts.type && (opts.type !== 'auto' && opts.type !== 'nonauto' && opts.type !== 'either')) {\n    throw new Error('type is not valid')\n  }\n  // default should be either \n  if (opts.type === 'auto' || opts.type === 'nonauto') {\n    type = opts.type;\n  }\n  return new Promise((resolve, reject) => {\n    if (type === 'nonauto') {\n      getNonAutoSubs(videoId)\n      .then((url) => {\n        const result = {\n          automaticallyGenerated: false,\n          url,\n        };\n        resolve(result);\n      })\n      .catch(err => {\n        if (err.message.indexOf(\"video doesn't have subtitles\")) {\n          // reject(new NonExistentSubtitleError(`Non-auto Subtitles dont exist for ${videoId}`));\n          reject(`Subtitles dont exist for ${videoId}`);\n        } else {\n          reject(err);\n        }\n      })\n    } else if (type === 'auto') {\n      getAutoSubs(videoId)\n      .then((url) => {\n        const result = {\n          automaticallyGenerated: true,\n          url,\n        };\n        resolve(result);\n      })\n      .catch(err => {\n        if (err.message.indexOf(\"Couldn't find automatic captions for\")) {\n          // reject(new NonExistentSubtitleError(`Auto Subtitles dont exist for ${videoId}`));\n          reject(`Auto Subtitles dont exist for ${videoId}`);\n        } else {\n          reject(err);\n        }\n      });\n    } else if (type === 'either') {\n      getNonAutoSubs(videoId)\n      .then((url) => {\n        const result = {\n          automaticallyGenerated: false,\n          url,\n        };\n        resolve(result);\n      })\n      .catch(() => {\n        getAutoSubs(videoId)\n        .then((url) => {\n          const result = {\n            automaticallyGenerated: true,\n            url,\n          };\n          resolve(result);\n        })\n        .catch(err => {\n          if (err.message.indexOf(\"Couldn't find automatic captions for\")) {\n            // reject(new NonExistentSubtitleError(`Subtitles dont exist for ${videoId}`));\n            reject(`Auto Subtitles dont exist for ${videoId}`);\n          } else {\n            reject(err);\n          }\n        });\n      });\n    }\n  });\n}\n\n// export default getYoutubeSubtitleUrl;\nmodule.exports = {\n  default: getYoutubeSubtitleUrl\n}\n\n"]},"metadata":{},"sourceType":"script"}