{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar path = require('path');\n\nvar util = require('util');\n\nvar spawn = require('child_process').spawn;\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n\nfunction extend(obj) {\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\n * An interactive Python shell exchanging data through stdio\n * @param {string} script    The python script to execute\n * @param {object} [options] The launch options (also passed to child_process.spawn)\n * @constructor\n */\n\n\nvar PythonShell = function (script, options) {\n  function resolve(type, val) {\n    if (typeof val === 'string') {\n      // use a built-in function using its name\n      return PythonShell[type][val];\n    } else if (typeof val === 'function') {\n      // use a custom function\n      return val;\n    }\n  }\n\n  var self = this;\n  var errorData = '';\n  EventEmitter.call(this);\n  options = extend({}, PythonShell.defaultOptions, options);\n  var pythonPath = options.pythonPath || 'python';\n  var pythonOptions = toArray(options.pythonOptions);\n  var scriptArgs = toArray(options.args);\n  this.script = path.join(options.scriptPath || './', script);\n  this.command = pythonOptions.concat(this.script, scriptArgs);\n  this.mode = options.mode || 'text';\n  this.formatter = resolve('format', options.formatter || this.mode);\n  this.parser = resolve('parse', options.parser || this.mode);\n  this.terminated = false;\n  this.childProcess = spawn(pythonPath, this.command, options);\n  ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n    self[name] = self.childProcess[name];\n    self.parser && self[name].setEncoding(options.encoding || 'utf8');\n  }); // parse incoming data on stdout\n\n  if (this.parser) {\n    this.stdout.on('data', PythonShell.prototype.receive.bind(this));\n  } // listen to stderr and emit errors for incoming data\n\n\n  this.stderr.on('data', function (data) {\n    errorData += '' + data;\n  });\n  this.stderr.on('end', function () {\n    self.stderrHasEnded = true;\n    terminateIfNeeded();\n  });\n  this.stdout.on('end', function () {\n    self.stdoutHasEnded = true;\n    terminateIfNeeded();\n  });\n  this.childProcess.on('exit', function (code) {\n    self.exitCode = code;\n    terminateIfNeeded();\n  });\n\n  function terminateIfNeeded() {\n    if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null) {\n      return;\n    }\n\n    var err;\n\n    if (errorData || self.exitCode !== 0) {\n      if (errorData) {\n        err = self.parseError(errorData);\n      } else {\n        err = new Error('process exited with code ' + self.exitCode);\n      }\n\n      err = extend(err, {\n        executable: pythonPath,\n        options: pythonOptions.length ? pythonOptions : null,\n        script: self.script,\n        args: scriptArgs.length ? scriptArgs : null,\n        exitCode: self.exitCode\n      }); // do not emit error if only a callback is used\n\n      if (self.listeners('error').length || !self._endCallback) {\n        self.emit('error', err);\n      }\n    }\n\n    self.terminated = true;\n    self.emit('close');\n    self._endCallback && self._endCallback(err);\n  }\n};\n\nutil.inherits(PythonShell, EventEmitter); // allow global overrides for options\n\nPythonShell.defaultOptions = {}; // built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; // built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\n/**\n * Runs a Python script and returns collected messages\n * @param  {string}   script   The script to execute\n * @param  {Object}   options  The execution options\n * @param  {Function} callback The callback function to invoke with the script results\n * @return {PythonShell}       The PythonShell instance\n */\n\nPythonShell.run = function (script, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  var pyshell = new PythonShell(script, options);\n  var output = [];\n  return pyshell.on('message', function (message) {\n    output.push(message);\n  }).end(function (err) {\n    if (err) return callback(err);\n    return callback(null, output.length ? output : null);\n  });\n};\n/**\n * Parses an error thrown from the Python process through stderr\n * @param  {string|Buffer} data The stderr contents to parse\n * @return {Error} The parsed error with extended stack trace when traceback is available\n */\n\n\nPythonShell.prototype.parseError = function (data) {\n  var text = '' + data;\n  var error;\n\n  if (/^Traceback/.test(text)) {\n    // traceback data is available\n    var lines = ('' + data).trim().split(/\\n/g);\n    var exception = lines.pop();\n    error = new Error(exception);\n    error.traceback = data; // extend stack trace\n\n    error.stack += '\\n    ----- Python Traceback -----\\n  ';\n    error.stack += lines.slice(1).join('\\n  ');\n  } else {\n    // otherwise, create a simpler error with stderr contents\n    error = new Error(text);\n  }\n\n  return error;\n};\n/**\n * Sends a message to the Python shell through stdin\n * Override this method to format data to be sent to the Python process\n * @param {string|Object} data The message to send\n * @returns {PythonShell} The same instance for chaining calls\n */\n\n\nPythonShell.prototype.send = function (message) {\n  var data = this.formatter ? this.formatter(message) : message;\n  if (this.mode !== 'binary') data += '\\n';\n  this.stdin.write(data);\n  return this;\n};\n/**\n * Parses data received from the Python shell stdout stream and emits \"message\" events\n * This method is not used in binary mode\n * Override this method to parse incoming data from the Python process into messages\n * @param {string|Buffer} data The data to parse into messages\n */\n\n\nPythonShell.prototype.receive = function (data) {\n  var self = this;\n  var parts = ('' + data).split(/\\n/g);\n\n  if (parts.length === 1) {\n    // an incomplete record, keep buffering\n    this._remaining = (this._remaining || '') + parts[0];\n    return this;\n  }\n\n  var lastLine = parts.pop(); // fix the first line with the remaining from the previous iteration of 'receive'\n\n  parts[0] = (this._remaining || '') + parts[0]; // keep the remaining for the next iteration of 'receive'\n\n  this._remaining = lastLine;\n  parts.forEach(function (part) {\n    self.emit('message', self.parser(part));\n  });\n  return this;\n};\n/**\n * Closes the stdin stream, which should cause the process to finish its work and close\n * @returns {PythonShell} The same instance for chaining calls\n */\n\n\nPythonShell.prototype.end = function (callback) {\n  this.childProcess.stdin.end();\n  this._endCallback = callback;\n  return this;\n};\n\nmodule.exports = PythonShell;","map":{"version":3,"sources":["C:/Users/b/Downloads/Compressed/BitNote-main/node_modules/python-shell/index.js"],"names":["EventEmitter","require","path","util","spawn","toArray","source","Array","isArray","extend","obj","prototype","slice","call","arguments","forEach","key","PythonShell","script","options","resolve","type","val","self","errorData","defaultOptions","pythonPath","pythonOptions","scriptArgs","args","join","scriptPath","command","concat","mode","formatter","parser","terminated","childProcess","name","setEncoding","encoding","stdout","on","receive","bind","stderr","data","stderrHasEnded","terminateIfNeeded","stdoutHasEnded","code","exitCode","err","parseError","Error","executable","length","listeners","_endCallback","emit","inherits","format","text","toText","toString","json","toJson","JSON","stringify","parse","asText","asJson","run","callback","pyshell","output","message","push","end","error","test","lines","trim","split","exception","pop","traceback","stack","send","stdin","write","parts","_remaining","lastLine","part","module","exports"],"mappings":"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","sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar path = require('path');\nvar util = require('util');\nvar spawn = require('child_process').spawn;\n\nfunction toArray(source) {\n    if (typeof source === 'undefined' || source === null) {\n        return [];\n    } else if (!Array.isArray(source)) {\n        return [source];\n    }\n    return source;\n}\n\nfunction extend(obj) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n        if (source) {\n            for (var key in source) {\n                obj[key] = source[key];\n            }\n        }\n    });\n    return obj;\n}\n\n/**\n * An interactive Python shell exchanging data through stdio\n * @param {string} script    The python script to execute\n * @param {object} [options] The launch options (also passed to child_process.spawn)\n * @constructor\n */\nvar PythonShell = function (script, options) {\n\n    function resolve(type, val) {\n        if (typeof val === 'string') {\n            // use a built-in function using its name\n            return PythonShell[type][val];\n        } else if (typeof val === 'function') {\n            // use a custom function\n            return val;\n        }\n    }\n\n    var self = this;\n    var errorData = '';\n    EventEmitter.call(this);\n\n    options = extend({}, PythonShell.defaultOptions, options);\n    var pythonPath = options.pythonPath || 'python';\n    var pythonOptions = toArray(options.pythonOptions);\n    var scriptArgs = toArray(options.args);\n\n    this.script = path.join(options.scriptPath || './', script);\n    this.command = pythonOptions.concat(this.script, scriptArgs);\n    this.mode = options.mode || 'text';\n    this.formatter = resolve('format', options.formatter || this.mode);\n    this.parser = resolve('parse', options.parser || this.mode);\n    this.terminated = false;\n    this.childProcess = spawn(pythonPath, this.command, options);\n\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n        self[name] = self.childProcess[name];\n        self.parser && self[name].setEncoding(options.encoding || 'utf8');\n    });\n\n    // parse incoming data on stdout\n    if (this.parser) {\n        this.stdout.on('data', PythonShell.prototype.receive.bind(this));\n    }\n\n    // listen to stderr and emit errors for incoming data\n    this.stderr.on('data', function (data) {\n        errorData += ''+data;\n    });\n\n    this.stderr.on('end', function(){\n        self.stderrHasEnded = true\n        terminateIfNeeded();\n    })\n\n    this.stdout.on('end', function(){\n        self.stdoutHasEnded = true\n        terminateIfNeeded();\n    })\n\n    this.childProcess.on('exit', function (code) {\n        self.exitCode = code;\n        terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n        if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null) {\n            return;\n        }\n        var err;\n        if (errorData || self.exitCode !== 0) {\n            if (errorData) {\n                err = self.parseError(errorData);\n            } else {\n                err = new Error('process exited with code ' + self.exitCode);\n            }\n            err = extend(err, {\n                executable: pythonPath,\n                options: pythonOptions.length ? pythonOptions : null,\n                script: self.script,\n                args: scriptArgs.length ? scriptArgs : null,\n                exitCode: self.exitCode\n            });\n            // do not emit error if only a callback is used\n            if (self.listeners('error').length || !self._endCallback) {\n                self.emit('error', err);\n            }\n        }\n        self.terminated = true;\n        self.emit('close');\n        self._endCallback && self._endCallback(err);\n    }\n};\nutil.inherits(PythonShell, EventEmitter);\n\n// allow global overrides for options\nPythonShell.defaultOptions = {};\n\n// built-in formatters\nPythonShell.format = {\n    text: function toText(data) {\n        if (!data) return '';\n        else if (typeof data !== 'string') return data.toString();\n        return data;\n    },\n    json: function toJson(data) {\n        return JSON.stringify(data);\n    }\n};\n\n// built-in parsers\nPythonShell.parse = {\n    text: function asText(data) {\n        return data;\n    },\n    json: function asJson(data) {\n        return JSON.parse(data);\n    }\n};\n\n/**\n * Runs a Python script and returns collected messages\n * @param  {string}   script   The script to execute\n * @param  {Object}   options  The execution options\n * @param  {Function} callback The callback function to invoke with the script results\n * @return {PythonShell}       The PythonShell instance\n */\nPythonShell.run = function (script, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    var pyshell = new PythonShell(script, options);\n    var output = [];\n\n    return pyshell.on('message', function (message) {\n        output.push(message);\n    }).end(function (err) {\n        if (err) return callback(err);\n        return callback(null, output.length ? output : null);\n    });\n};\n\n/**\n * Parses an error thrown from the Python process through stderr\n * @param  {string|Buffer} data The stderr contents to parse\n * @return {Error} The parsed error with extended stack trace when traceback is available\n */\nPythonShell.prototype.parseError = function (data) {\n    var text = ''+data;\n    var error;\n\n    if (/^Traceback/.test(text)) {\n        // traceback data is available\n        var lines = (''+data).trim().split(/\\n/g);\n        var exception = lines.pop();\n        error = new Error(exception);\n        error.traceback = data;\n        // extend stack trace\n        error.stack += '\\n    ----- Python Traceback -----\\n  ';\n        error.stack += lines.slice(1).join('\\n  ');\n    } else {\n        // otherwise, create a simpler error with stderr contents\n        error = new Error(text);\n    }\n\n    return error;\n};\n\n/**\n * Sends a message to the Python shell through stdin\n * Override this method to format data to be sent to the Python process\n * @param {string|Object} data The message to send\n * @returns {PythonShell} The same instance for chaining calls\n */\nPythonShell.prototype.send = function (message) {\n    var data = this.formatter ? this.formatter(message) : message;\n    if (this.mode !== 'binary') data += '\\n';\n    this.stdin.write(data);\n    return this;\n};\n\n/**\n * Parses data received from the Python shell stdout stream and emits \"message\" events\n * This method is not used in binary mode\n * Override this method to parse incoming data from the Python process into messages\n * @param {string|Buffer} data The data to parse into messages\n */\nPythonShell.prototype.receive = function (data) {\n    var self = this;\n    var parts = (''+data).split(/\\n/g);\n\n    if (parts.length === 1) {\n        // an incomplete record, keep buffering\n        this._remaining = (this._remaining || '') + parts[0];\n        return this;\n    }\n\n    var lastLine = parts.pop();\n    // fix the first line with the remaining from the previous iteration of 'receive'\n    parts[0] = (this._remaining || '') + parts[0];\n    // keep the remaining for the next iteration of 'receive'\n    this._remaining = lastLine;\n\n    parts.forEach(function (part) {\n        self.emit('message', self.parser(part));\n    });\n\n    return this;\n};\n\n/**\n * Closes the stdin stream, which should cause the process to finish its work and close\n * @returns {PythonShell} The same instance for chaining calls\n */\nPythonShell.prototype.end = function (callback) {\n    this.childProcess.stdin.end();\n    this._endCallback = callback;\n    return this;\n};\n\nmodule.exports = PythonShell;\n"]},"metadata":{},"sourceType":"script"}